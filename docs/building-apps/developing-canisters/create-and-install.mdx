---
keywords: [beginner, tutorial, create, create canister, compile code, compile canister, compile, build, install, canister install, install code]
---

import TabItem from "@theme/TabItem";
import Tabs from '@theme/Tabs';
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { AdornedTab } from "/src/components/Tabs/AdornedTab";
import { BetaChip } from "/src/components/Chip/BetaChip";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";

# Create canisters

<MarkdownChipRow labels={["Beginner", "Launching dapps"]} />

ICP smart contracts are called **canisters**. They are computational units that combine both code and data. Applications on ICP are comprised of one or more canisters. They can be used to create a wide variety of applications, such as serving web pages, creating a secure messaging app, or implementing a decentralized token exchange.

To learn more about canister concepts, review the following:

- [What are canisters?](/docs/building-apps/essentials/canisters)

- [Canister components](/docs/building-apps/essentials/canisters).

- [Canister lifecycle](/docs/building-apps/essentials/canisters).

## Creation workflow

1. Write the canister's source code. This can be done in any language of choice if that language supports compilation to WebAssembly. Several canister development kits (CDKs) exist to facilitate compiling code written in languages such as Rust, TypeScript, and Python into WebAssembly for deployment on ICP.

2. The canister must be created and registered with ICP, either locally, on the playground, or on the mainnet. When a canister is initially created, it is empty and does not contain code or state; it only contains the canister settings, canister ID, cycles balance, and controllers.

3. The canister's source code must then be compiled into WebAssembly.

4. The WebAssembly module must be installed into the canister.

After these steps have been completed, the canister can be deployed and interacted with.

The [`dfx deploy`](/docs/building-apps/developing-canisters/deploy) command does several of these steps in the background; this guide will demonstrate how to execute each step separately. However, this is not necessary for all workflows.

## 1. Writing canister code

ICP supports a wide range of applications and architecture types.
Apps can range from a single canister to complex, multi-<GlossaryTooltip>canister</GlossaryTooltip> projects and everything in between.

You can begin writing and structuring your application using one of two primary workflows:

- **Standard workflow**: The developer writes both the frontend and backend code, then deploys both to ICP as canisters.

- **Framework-based workflow**: An external framework is used to help facilitate creating and deploying canisters. [Learn more about frameworks](#framework-based-workflow).

### Standard workflow

#### Choosing the programming language for the backend

The backend stores the application’s data and contains the core logic.
Several languages are supported, such as:

- **[Motoko](/docs/motoko/main/getting-started/motoko-introduction)**: Supported by [DFINITY](https://github.com/dfinity/motoko). Motoko is production-ready and was specifically designed to onboard developers onto ICP and leverage the actor-based programming model of ICP. It is a high-level language with a garbage collector and syntax that is similar to TypeScript.
Examples of production canisters that use Motoko include [ICDex](https://github.com/iclighthouse/ICDex) and [CycleOps](https://github.com/CycleOperators/cycles-manager). [Learn more about using Motoko](/docs/motoko/main/getting-started/motoko-introduction).

- **[Rust](/docs/building-apps/developer-tools/cdks/rust/intro-to-rust)**: Supported by [DFINITY](https://github.com/dfinity/cdk-rs). Currently, Rust is the language with the most production coverage for ICP applications.
All system canisters, such as [the DAO governing ICP](https://github.com/dfinity/ic/tree/master/rs/nns), [the ICP ledger](https://github.com/dfinity/ic/tree/master/rs/ledger_suite/icp), and the [Bitcoin](https://github.com/dfinity/bitcoin-canister) and [Ethereum](https://github.com/dfinity/ic/tree/master/rs/ethereum) integration canisters, are written in Rust. This language gives the developer full control over all aspects of the canister, starting from performance to memory management.
The only disadvantage of Rust is that it is lower-level compared to other languages and requires more expert programming skills to write safe and secure code.
[Learn more about using Rust](/docs/building-apps/developer-tools/cdks/rust/intro-to-rust).

- **TypeScript (beta)**: Supported by [Demergent Labs](https://github.com/demergent-labs) under the name Azle. Azle is in beta. Please check [the Azle website](https://demergent-labs.github.io/azle/) for more information.

- **Python (beta)**: Supported by [Demergent Labs](https://github.com/demergent-labs) under the name Kybra. Kybra is in beta. Please check [the Kybra website](https://demergent-labs.github.io/kybra/kybra.html) for more information.

- **[C++](https://docs.icpp.world/)**: Supported through the [C++ CDK](https://docs.icpp.world/).

#### Choosing a web framework for the frontend

The [HTTP Gateway protocol](/docs/references/http-gateway-protocol-spec) of ICP allows browsers to load web assets such as JS, HTML, and CSS from a canister via HTTP.
This means that [web assets can be stored fully onchain](/docs/building-apps/frontends/using-an-asset-canister) and developers don’t need to use traditional centralized web hosting to serve the UI of their application.

[Svelte](https://svelte.dev/), [React](https://react.dev/), and [Vue](https://vuejs.org/) have been used successfully in production. `dfx v0.17.0` and newer can be used to generate project templates that include one of these frameworks.

Having no frontend at all is also a valid option for canisters that don’t have a UI and are callable only by users or other canisters. [Learn more](/docs/building-apps/frontends/using-an-asset-canister).

#### Using `dfx new`

<Tabs>
<TabItem value="prereq" label="Prerequisites" default>

<input type="checkbox"/> <a href="/docs/building-apps/getting-started/install">Install the IC SDK.</a>
<div>
</div>
<input type="checkbox"/> Download and install an IDE or code editor. <a href="https://code.visualstudio.com/">VS Code</a> is recommended.

For writing Motoko code, the [Motoko VS Code extension](https://marketplace.visualstudio.com/items?itemName=dfinity-foundation.vscode-motoko) is highly recommended for syntax highlighting.

</TabItem>
</Tabs>

Create a new project. When prompted, select your backend language and frontend framework of choice:

```bash
dfx new <project-name>
```

The [`dfx new`](/docs/building-apps/developer-tools/dfx/dfx-new) command creates a new project directory containing template files and a new `<project_name>` Git repository for your project.

When creating new projects with `dfx new`, only alphanumeric characters and underscores should be used. This is to assure that project names are valid within Motoko, JavaScript, and other contexts.

#### Using an existing sample project

You can also obtain projects from other sources, such as [ICP Ninja](https://icp.ninja) or the [sample repository](https://github.com/dfinity/examples). If you are obtaining a project from a source other than the `dfx new` command, confirm that the project's root directory contains a `dfx.json` file that defines the project's canisters.

#### Navigate into your project directory

From the command line, navigate into your project directory with the command:

```
cd <project-name>
```

The project structure will resemble the following. If you are using an ICP Ninja project or other sample project, project structure may vary.

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

```bash
<project-name>/
├── README.md      # Default project documentation
├── dfx.json       # Project configuration file
├── node_modules   # Libraries for frontend development
├── package-lock.json
├── package.json
├── src            # Source files directory
│   ├── <project-name>_backend
│   │   └── main.mo
│   ├── <project-name>_frontend
│       ├── assets
│       │   ├── logo.png
│       │   ├── main.css
│       │   └── sample-asset.txt
│       └── src
│           ├── index.html
│           └── index.js
└── webpack.config.js
```

</TabItem>
<TabItem value="rust" label="Rust">

```bash
<project-name>/
├── README.md      # Default project documentation
├── dfx.json       # Project configuration file
├── node_modules   # Libraries for frontend development
├── package-lock.json
├── package.json
├── src            # Source files directory
│   ├── <project-name>_backend
│   │   └── Cargo.toml
│   │   └── <project-name>_backend.did
│   │   └── src
│       │   ├── lib.rs
│   ├── <project-name>_frontend
│       ├── assets
│       │   ├── logo.png
│       │   ├── main.css
│       │   └── sample-asset.txt
│       └── src
│           ├── index.html
│           └── index.js
└── webpack.config.js
```

</TabItem>

</AdornedTabs>

In this directory, the following files and directories are notable:

- `README.md`: The default README file to be used for documenting your project.
- `dfx.json`: The default ICP configuration file used to set configurable options for your project.
- `src/`: The source directory that contains all of your dapp's source files.
- `<project-name>_backend`: The source directory that contains your dapp's backend code files.
- `<project-name>_frontend`: The source directory that contains your dapp's frontend code files.

### Framework-based workflow

#### Juno
[Juno](https://juno.build/docs/intro) is a community project that is tailored for Web2 developers. It takes care of hosting code and data in canisters such that developers can write Web3 applications using familiar Web2 concepts and patterns. For more details, please follow [the official Juno documentation](https://juno.build/docs/intro).

#### Bitfinity EVM

[Bitfinity EVM](https://docs.bitfinity.network/) is tailored for Solidity developers. It is a canister that runs an instance of the Ethereum virtual machine and allows developers to upload and execute canisters written in Solidity. For more details, please follow [the official Bitfinity documentation](https://docs.bitfinity.network/).

## 2. Create a new canister

Canisters are created with [`dfx canister create`](/docs/building-apps/developer-tools/dfx/dfx-canister#dfx-canister-create). They are initially empty and do not contain program code. The code must be [compiled](/docs/building-apps/developing-canisters/what-is-a-canister) into Wasm and [installed](/docs/building-apps/developing-canisters/what-is-a-canister) into the empty canister before it can be deployed.

Create your canisters from within the project's directory:

- `dfx canister create <canister-name> --network=local`: Create a canister locally. The local replica must be running to create a canister locally. Start it with `dfx start --background`.

- `dfx canister create <canister-name> --network=playground`: Create a canister on the [playground](/docs/building-apps/developing-canisters/deploy#testnets). Creating a canister on the playground is free, but canisters are temporary and will be removed after 20 minutes.

- `dfx canister create <canister-name> --network=ic`: Create a canister on the mainnet. Creating a canister on the mainnet will cost [cycles](/docs/building-apps/essentials/gas-cost).

- `dfx canister create --all --network=ic`: Create all canisters in the project's `dfx.json` file on the mainnet.

Settings can be configured while creating a canister using optional flags. [View the full list of settings](/docs/building-apps/developer-tools/dfx/dfx-canister#dfx-canister-create).

When a canister is created, the following steps happen:

- A canister ID is registered with the local replica or the mainnet for each canister in the project's `dfx.json` file.

- The following canister components are created:
  - List of controllers.
  - Cycles balance.
  - Reserved cycles balance.
  - Canister status.
  - Resource reservations.

- Each canister ID is returned in the command line.

### Errors related to canister creation

Common errors related to canister creation include:

- [Canister not found](/docs/references/execution-errors#canister-not-found).
- [Maximum number of canisters reached](/docs/references/execution-errors#maximum-number-of-canisters-reached).

## 3. Compile canister code into WebAssembly

After you have created your canisters, you need to compile the code into a WebAssembly module before it can be deployed on ICP.

:::danger

You must create your canisters before you can build them; otherwise, you will receive an error message saying they do not exist.

:::

[`dfx build`](/docs/building-apps/developer-tools/dfx/dfx-build) looks for source code to compile for each canister configured under the `canisters` section in the [`dfx.json`](/docs/building-apps/developer-tools/dfx-json-reference) file. `dfx build` can be used to compile a specific canister or all canisters defined in the project.

Verify the location of your project's files and their file names. If necessary, edit your project's `dfx.json` file to reflect the current intended configuration.

Compile your canisters from within the project's directory:

```
dfx build <canister-name> --network=<NETWORK>
```

Compilation happens on the local machine of the developer. `dfx build` isn't the only workflow that can be used for compiling code. For example, Rust canisters can be compiled using `cargo`.

When this command is executed, the following steps happen:

- The source code for a canister is compiled into a Wasm module.

- If a canister is written in Motoko, type declarations are automatically generated using Candid.

- If a canister is written in Rust, the build process checks for Rust vulnerabilities.

### How code is compiled to Wasm

WebAssembly (Wasm) is a platform-independent binary format that can be executed in the Wasm virtual machine.
Many modern compilers support Wasm as the compilation target along with traditional targets such as x86 and arm32.

There are three types of Wasm depending on where the Wasm virtual machine is hosted and how it interacts with users and the host environment:

- **Web browser**: The Wasm program interacts with the users via the JavaScript bindings of the browser. The primary toolchain for compiling Wasm for browsers is [Emscripten](https://emscripten.org/). Note that such Wasm programs are incompatible with ICP.

- **WASI**: This abbreviation stands for [WebAssembly System Interface](https://wasi.dev/). It is becoming the standard for running Wasm programs outside of web browsers. Major Wasm runtimes such as Wasmtime and Wasmer support this standard. Compilers denote this target as `wasm32-wasi`. ICP does not directly support WASI, but it is possible to preprocess a WASI program and make it runnable on ICP with the community project [`wasi2ic`](https://github.com/wasm-forge/wasi2ic).

- **Vanilla Wasm**: There is no standard API for interacting with users and the host environment. Every host environment provides its own API. ICP uses this approach and provides a set of functions, called the System API, to the Wasm program. Many compilers denote this target as `wasm32-unknown-unknown` since they do not know the target host environment and do not make any assumptions about the available APIs.

The Canister Development Kit (CDK) of supported programming language comes with build scripts that link the System API and compile the code to Wasm programs that are compatible with ICP:

- Rust and Motoko compile to the `wasm32-unknown-unknown` target directly under the hood.
- Azle and Kybra first compile to the `wasm32-wasi` target and then convert the Wasm binary to `wasm32-unknown-unknown` using the `wasi2ic` tool.

For the convenience of developers, `dfx` wraps the CDK-specific build scripts and provides the `dfx build` command to compile the code to a Wasm binary.

## 4. Install Wasm modules

Compiled Wasm modules must be installed into a canister using the [`dfx canister install`](/docs/building-apps/developer-tools/dfx/dfx-canister#dfx-canister-install) command from the project's directory:

```
dfx canister install <canister-name> --network=<NETWORK>
```

When a canister's code is installed, the following components are created:

- The canister's code in the form of a canister module.

- The canister's state, including the canister's memory and global values.

- Additional IC-specific information, such as the canister's input and output queues.

### Installing a gzip-compressed WebAssembly module

The size of programs that can be installed on ICP is currently limited to 10 MiB.
WebAssembly modules that are (slightly) larger than 10 MiB can still be installed on ICP by using gzip file compression before uploading. ICP will then decompress the file and install the contained WebAssembly module.

The WebAssembly module is compressed using `gzip` and then uploaded by `dfx canister install`. You may need to add `--mode reinstall` or `--mode upgrade` when uploading the module to an existing canister.

``` bash
gzip my-canister.wasm
dfx canister install my-canister --wasm my-canister.wasm.gz
```

Compression is currently not supported by `dfx deploy`.

### Errors related to Wasm modules

Common errors related to installation and Wasm modules include:

- [Install code rate limited](/docs/references/execution-errors#install-code-rate-limited).
- [Canister not empty](/docs/references/execution-errors#canister-not-empty).
- [Wasm module not found](/docs/references/execution-errors#wasm-module-not-found).
- [Wasm module too large](/docs/references/execution-errors#wasm-module-too-large).
- [Wasm module duplicate exports](/docs/references/execution-errors#wasm-module-duplicate-exports).
- [Wasm module exports too many methods](/docs/references/execution-errors#wasm-module-exports-too-many-methods).
- [Wasm module sum of exported name lengths too large](/docs/references/execution-errors#wasm-module-sum-of-exported-name-lengths-too-large).
- [Wasm module too many functions](/docs/references/execution-errors#wasm-module-too-many-functions).
- [Wasm module too many globals](/docs/references/execution-errors#wasm-module-too-many-globals).
- [Wasm module function complexity too high](/docs/references/execution-errors#wasm-module-function-complexity-too-high).
- [Wasm module function too large](/docs/references/execution-errors#wasm-module-function-too-large).
- [Wasm module code section too large](/docs/references/execution-errors#wasm-module-code-section-too-large).