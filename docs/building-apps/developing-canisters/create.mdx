---
keywords: [beginner, tutorial, create, create canister, compile code, compile canister, compile, build, install, canister install, install code]
---

import TabItem from "@theme/TabItem";
import Tabs from '@theme/Tabs';
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { AdornedTab } from "/src/components/Tabs/AdornedTab";
import { BetaChip } from "/src/components/Chip/BetaChip";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";

# Create

<MarkdownChipRow labels={["Beginner", "Developing canisters"]} />

ICP smart contracts are called **canisters**. They are computational units that combine both code and data. Applications on ICP are comprised of one or more canisters. They can be used to create a wide variety of applications, such as serving web pages, creating a secure messaging app, or implementing a decentralized token exchange.

To learn more about canister concepts, review the following:

- [What are canisters?](/docs/building-apps/essentials/canisters)

## Creation workflow

1. Write the canister's source code. This can be done in any language of choice if that language supports compilation to WebAssembly. Several canister development kits (CDKs) exist to facilitate compiling code written in languages such as Rust, TypeScript, and Python into WebAssembly for deployment on ICP.

2. The canister must be created and registered with ICP, either locally, on the playground, or on the mainnet. When a canister is initially created, it is empty and does not contain code or state; it only contains the canister settings, canister ID, cycles balance, and controllers.

3. The canister's source code must then be compiled into WebAssembly.

4. The WebAssembly module must be installed into the canister.

After these steps have been completed, the canister can be deployed and interacted with.

The [`dfx deploy`](/docs/building-apps/developing-canisters/deploy) command does several of these steps in the background; this guide will demonstrate how to execute each step separately. However, this is not necessary for all workflows.

ICP supports a wide range of applications and architecture types.
Apps can range from a single canister to complex, multi-<GlossaryTooltip>canister</GlossaryTooltip> projects and everything in between.

You can begin writing and structuring your application using one of two primary workflows:

- **Standard workflow**: The developer writes both the frontend and backend code, then deploys both to ICP as canisters.

- **Framework-based workflow**: An external framework is used to help facilitate creating and deploying canisters. [Learn more about frameworks](#framework-based-workflow).

### Standard workflow

#### Choosing the programming language for the backend

The backend stores the application’s data and contains the core logic.
Several languages are supported, such as:

- **[Motoko](/docs/motoko/main/getting-started/motoko-introduction)**: Supported by [DFINITY](https://github.com/dfinity/motoko). Motoko is production-ready and was specifically designed to onboard developers onto ICP and leverage the actor-based programming model of ICP. It is a high-level language with a garbage collector and syntax that is similar to TypeScript.
Examples of production canisters that use Motoko include [ICDex](https://github.com/iclighthouse/ICDex) and [CycleOps](https://github.com/CycleOperators/cycles-manager). [Learn more about using Motoko](/docs/motoko/main/getting-started/motoko-introduction).

- **[Rust](/docs/building-apps/developer-tools/cdks/rust/intro-to-rust)**: Supported by [DFINITY](https://github.com/dfinity/cdk-rs). Currently, Rust is the language with the most production coverage for ICP applications.
All system canisters, such as [the DAO governing ICP](https://github.com/dfinity/ic/tree/master/rs/nns), [the ICP ledger](https://github.com/dfinity/ic/tree/master/rs/ledger_suite/icp), and the [Bitcoin](https://github.com/dfinity/bitcoin-canister) and [Ethereum](https://github.com/dfinity/ic/tree/master/rs/ethereum) integration canisters, are written in Rust. This language gives the developer full control over all aspects of the canister, starting from performance to memory management.
The only disadvantage of Rust is that it is lower-level compared to other languages and requires more expert programming skills to write safe and secure code.
[Learn more about using Rust](/docs/building-apps/developer-tools/cdks/rust/intro-to-rust).

- **TypeScript (beta)**: Supported by [Demergent Labs](https://github.com/demergent-labs) under the name Azle. Azle is in beta. Please check [the Azle website](https://demergent-labs.github.io/azle/) for more information.

- **Python (beta)**: Supported by [Demergent Labs](https://github.com/demergent-labs) under the name Kybra. Kybra is in beta. Please check [the Kybra website](https://demergent-labs.github.io/kybra/kybra.html) for more information.

- **[C++](https://docs.icpp.world/)**: Supported through the [C++ CDK](https://docs.icpp.world/).

#### Choosing a web framework for the frontend

The [HTTP Gateway protocol](/docs/references/http-gateway-protocol-spec) of ICP allows browsers to load web assets such as JS, HTML, and CSS from a canister via HTTP.
This means that [web assets can be stored fully onchain](/docs/building-apps/frontends/using-an-asset-canister) and developers don’t need to use traditional centralized web hosting to serve the UI of their application.

[Svelte](https://svelte.dev/), [React](https://react.dev/), and [Vue](https://vuejs.org/) have been used successfully in production. `dfx v0.17.0` and newer can be used to generate project templates that include one of these frameworks.

Having no frontend at all is also a valid option for canisters that don’t have a UI and are callable only by users or other canisters. [Learn more](/docs/building-apps/frontends/using-an-asset-canister).

#### Creating a project

<Tabs>
<TabItem value="prereq" label="Prerequisites" default>

<input type="checkbox"/> <a href="/docs/building-apps/getting-started/install">Install the IC SDK.</a>
<div>
</div>
<input type="checkbox"/> Download and install an IDE or code editor. <a href="https://code.visualstudio.com/">VS Code</a> is recommended.

For writing Motoko code, the [Motoko VS Code extension](https://marketplace.visualstudio.com/items?itemName=dfinity-foundation.vscode-motoko) is highly recommended for syntax highlighting.

</TabItem>
</Tabs>

Before creating a canister, you need to create a project by running the command:

```
dfx new PROJECT_NAME --type=motoko
cd PROJECT_NAME
```

Options for the `--type` flag are `motoko`, `rust`, `azle`, and `kybra`. Using [Rust](/docs/building-apps/developer-tools/cdks/rust/intro-to-rust), [Azle](https://demergent-labs.github.io/azle//), or [Kybra](https://demergent-labs.github.io/kybra/) may require additional dependencies to be installed if you have not developed with those languages in your environment before. View their corresponding documentation for more information.

You should be in a directory that contains a file called `dfx.json`. This file is used to configure your project's settings. It includes the project's canister definitions, such as the canister's type, source code file, and dependencies.

```json title=dfx.json
{
  "canisters": {
    "PROJECT_NAME_backend": { // Backend canister name
      "main": "src/PROJECT_NAME_backend/main.mo", // Backend canister source code
      "type": "motoko" // Canister language
    },
    "PROJECT_NAME_frontend": { // Frontend canister name
      "dependencies": [
        "PROJECT_NAME_backend"
      ],
      "source": [
        "src/PROJECT_NAME_frontend/dist" // Frontend canister source code
      ],
      "type": "assets", // All frontend canisters will have type 'assets' regardless of the frontend framework used
      "workspace": "PROJECT_NAME_frontend"
    }
  },
  "defaults": {
    "build": {
      "args": "",
      "packtool": ""
    }
  },
  "output_env_file": ".env",
  "version": 1
}
```

When creating new projects with `dfx new`, only alphanumeric characters and underscores should be used. This is to assure that project names are valid within Motoko, JavaScript, and other contexts.

#### Using an existing sample project

You can also obtain projects from other sources, such as [ICP Ninja](https://icp.ninja) or the [sample repository](https://github.com/dfinity/examples). If you are obtaining a project from a source other than the `dfx new` command, confirm that the project's root directory contains a `dfx.json` file that defines the project's canisters.

### Framework-based workflow

#### Juno
[Juno](https://juno.build/docs/intro) is a community project that is tailored for Web2 developers. It takes care of hosting code and data in canisters such that developers can write Web3 applications using familiar Web2 concepts and patterns. For more details, please follow [the official Juno documentation](https://juno.build/docs/intro).

#### Bitfinity EVM

[Bitfinity EVM](https://docs.bitfinity.network/) is tailored for Solidity developers. It is a canister that runs an instance of the Ethereum virtual machine and allows developers to upload and execute canisters written in Solidity. For more details, please follow [the official Bitfinity documentation](https://docs.bitfinity.network/).

## Create a canister

Once you have a project that contains a `dfx.json` file defining a project's canisters, you can create one of those canisters using the `dfx canister create` command.

:::info
Canister creation is done automatically in the background of the `dfx deploy` command. However, there may be certain workflows where creating an empty canister is necessary.
:::

Canisters are created with [`dfx canister create`](/docs/building-apps/developer-tools/dfx/dfx-canister#dfx-canister-create). They are initially empty and do not contain program code. The code must be [compiled](/docs/building-apps/developing-canisters/what-are-canisters) into Wasm and [installed](/docs/building-apps/developing-canisters/what-are-canisters) into the empty canister before it can be deployed.

Create your canisters from within the project's directory:

- `dfx canister create <canister-name> --network=local`: Create a canister locally. The local replica must be running to create a canister locally. Start it with `dfx start --background`.

- `dfx canister create <canister-name> --network=playground`: Create a canister on the [playground](/docs/building-apps/developing-canisters/deploy#testnets). Creating a canister on the playground is free, but canisters are temporary and will be removed after 20 minutes.

- `dfx canister create <canister-name> --network=ic`: Create a canister on the mainnet. Creating a canister on the mainnet will cost [cycles](/docs/building-apps/essentials/gas-cost).

- `dfx canister create --all --network=ic`: Create all canisters in the project's `dfx.json` file on the mainnet.

Settings can be configured while creating a canister using optional flags. [View the full list of settings](/docs/building-apps/developer-tools/dfx/dfx-canister#dfx-canister-create).

When a canister is created, the following steps happen:

- A canister ID is registered with the local replica or the mainnet for each canister in the project's `dfx.json` file.

- The following canister components are created:
  - List of controllers.
  - Cycles balance.
  - Reserved cycles balance.
  - Canister status.
  - Resource reservations.

- Each canister ID is returned in the command line.

### Errors related to canister creation

Common errors related to canister creation include:

- [Canister not found](/docs/references/execution-errors#canister-not-found).
- [Maximum number of canisters reached](/docs/references/execution-errors#maximum-number-of-canisters-reached).