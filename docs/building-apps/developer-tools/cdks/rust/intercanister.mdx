---
keywords: [beginner, rust, tutorial, inter-canister, calls]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

# Inter-canister calls

<MarkdownChipRow labels={["Beginner", "Rust"]} />

Inter-canister calls can be used to update information between two or more canisters.

To demonstrate these inter-canister calls, you'll use an example project called "PubSub."

A common problem in both distributed and decentralized systems is keeping separate services (or canisters) synchronized with one another. While there are many potential solutions to this problem, a popular one is the **publisher/subscriber** pattern, or "PubSub." PubSub is an especially valuable pattern on ICP as its primary drawback, message delivery failures, does not apply.

<Tabs>
<TabItem value="prereq" label="Prerequisites" default>

<input type="checkbox"/> <a href="/docs/building-apps/getting-started/install">Install the IC SDK.</a> Note: While using the IC SDK is the typical path for most developers, experienced Rust developers may choose to circumvent IC SDK entirely and use the <a href="https://github.com/dfinity/cdk-rs"> Rust CDK </a> directly.
<div>
</div>
<input type="checkbox"/> <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Download and install Rust.</a>
<div>
</div>
<input type="checkbox"/> Download and install the <code>wasm32-unknown-unknown</code> target: <code>rustup target add wasm32-unknown-unknown</code>
</TabItem>
</Tabs>

## Viewing the canister code

Download the sample project's files with the commands:

```bash
git clone https://github.com/dfinity/examples/
cd examples/rust/pub-sub/
```

This project is comprised of two canisters: publisher and subscriber.

The **subscriber** canister contains a record of topics. The **publisher** canister uses inter-canister calls to add topics to the record within the subscriber canister.

Let's take a look at the `src/lib.rs` file for each of these canisters.

```rust file=../../../../references/samples/rust/pub-sub/src/publisher/src/lib.rs
```

In this code, you can see two inter-canister update calls: `fn subscribe(subscriber: Subscriber)` and `async fn publish(counter: Counter)`. The first method allows the subscriber canister to make a call to the publisher canister and subscribe to topics. The second method allows the publisher canister to publish information on a topic in the subscriber canister.

```rust file=../../../../references/samples/rust/pub-sub/src/subscriber/src/lib.rs
```

In this code, there are three main methods: two inter-canister update methods and a query method.

The first method, `async fn setup_subscribe(publisher_id: Principal, topic: String)` provides functionality for the publisher canister to subscribe to topics within the `subscriber` canister. This function is called by the publisher canister.

The second method, `fn update_count(counter: Counter)` updates the counter record for each published value in a topic within the subscriber canister.

The third method, `fn get_count() -> u64` allows the `Counter` value to be queried and returned in a call.

## Deploying the canisters

Now that you've taken a look at your canisters, let's deploy them.

Open a terminal window on your local computer, if you donâ€™t already have one open.

Then run the commands:

```bash
dfx start --clean --background
dfx deploy
```

## Making inter-canister calls

First, let's subscribe to a topic. For example, to subscribe to the "Apples" topic, use the command:

```bash
dfx canister call subscriber setup_subscribe '(principal "<INSERT_PUBLISHER_PRINCIPAL_HERE>", "Apples")'
```

Then, to publish a record to the "Apples" topic, use the command:

```bash
dfx canister call publisher publish '(record { "topic" = "Apples"; "value" = 2 })'
```

Then, you can query and receive the subscription record value with the command:

```bash
dfx canister call subscriber get_count
```

The output should resemble the following:

```bash
(2 : nat64)
```