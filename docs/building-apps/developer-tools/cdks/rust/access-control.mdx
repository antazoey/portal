---
keywords: [intermediate, rust, tutorial, access control]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

# Access control with NFTs

<MarkdownChipRow labels={["Intermediate", "Rust", "Tutorial"]} />

To demonstrate access control using a Rust backend canister, you'll explore access control in the context of NFTs. NFTs (non-fungible tokens) are unique tokens with arbitrary
metadata, usually an image of some kind, to form the digital equivalent of trading cards.

The current NFT standards on ICP are the ICRC-7 and ICRC-37 standards, which define parameters for NFTs and the transfer of NFTs on behalf of another use. However, for the purposes of this example, you will use the older NFT standard [DIP-721](https://github.com/Psychedelic/DIP721), as it demonstrates multiple levels of access control using a Rust example. You can see a quick introduction on [YouTube](https://youtu.be/1po3udDADp4).

[DIP-721](https://github.com/Psychedelic/DIP721) specifies three levels of access control:
- **Owner**: This person owns an NFT. They can transfer the NFT, add/remove operators, or burn the NFT.
- **Operator**: A type of delegated owner. The operator does not own the NFT, but can do the same actions an owner can do.
- **Custodian**: Creator of the NFT collection/canister. They can do anything (transfer, add/remove operators, burn, and even un-burn) to NFTs, but also mint new ones or change the symbol or description of the collection.

The NFT example canister keeps access control very simple:
- For every level of control, a separate list (or set) of principals is kept.
- Those three levels are then manually checked every single time someone attempts to do something for which they require authorization.
- If a user is not authorized to call a certain function, an error is returned.

## Creating the project

For developing Rust canisters on ICP, you will need the following tools and packages:

<Tabs>
<TabItem value="prereq" label="Prerequisites" default>

<input type="checkbox"/> <a href="/docs/building-apps/getting-started/install">Install the IC SDK.</a> Note: While using the IC SDK is the typical path for most developers, experienced Rust developers may choose to circumvent IC SDK entirely and use the <a href="https://github.com/dfinity/cdk-rs"> Rust CDK </a> directly.
<div>
</div>
<input type="checkbox"/> <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Download and install Rust.</a>
<div>
</div>
<input type="checkbox"/> Download and install the <code>wasm32-unknown-unknown</code> target: <code>rustup target add wasm32-unknown-unknown</code>

</TabItem>
</Tabs>

Start by cloning the Github repo for the project's files and navigate into the directory with the commands:

```sh
git clone https://github.com/dfinity/examples
cd examples/rust/dip721-nft-container
```

Let's review the `src/lib.rs` file which defines the permissions in the canister:

```rust file=../../../../references/samples/rust/dip721-nft-container/src/lib.rs
```

Then, start the local replica before installing the canister:

```sh
dfx start --clean --background
```

Then, install the canister with the following passed argument:

```sh
dfx deploy --no-wallet --argument \
"(record {
    name = \"Numbers One Through Fifty\";
    symbol = \"NOTF\";
    logo = opt record {
        data = \"$(base64 -i ./logo.png)\";
        logo_type = \"image/png\";
    };
    custodians = opt vec { principal \"$(dfx identity get-principal)\" };
})"
```

The canister expects a record parameter with the following fields:

- `custodians`: A list of users allowed to manage the canister. If unset, it will default to the caller. If you're using `dfx`, and haven't specified `--no-wallet`, that's your wallet principal, not your own, so be careful!
- `name`: The name of your NFT collection. Required.
- `symbol`: A short slug identifying your NFT collection. Required.
- `logo`: The logo of your NFT collection, represented as a record with fields `data` (the base-64 encoded logo) and `logo_type` (the MIME type of the logo file). If unset, it will default to the Internet Computer logo.

## Interacting with the canister

Now you can interact with the canister. Aside from the standard functions, it has five extra functions:

- `set_name`, `set_symbol`, `set_logo`, and `set_custodian`: Update the collection information of the corresponding field from when it was initialized.
- `is_custodian`: Checks whether the specified user is a custodian.

The canister also supports a certified HTTPS interface; going to `/<nft>/<id>` will return `nft`'s metadata file #`id`, with `/<nft>` returning the first non-preview file.

:::info
Remember that query functions are uncertified; the result of functions like `ownerOfDip721` can be modified arbitrarily by a single malicious node. If queried information is depended on, for example if someone might send ICP to the owner of a particular NFT to buy it from them, those calls should be performed as update calls instead. You can force an update call by passing the `--update` flag to `dfx` or using the `Agent::update` function in `the [ICP Rust agent](https://docs.rs/ic-agent/latest/ic_agent/)`.
:::

To test functionality, you can try to mint an NFT.

Due to size limitations on the length of a terminal command, an image- or video-based NFT would be impossible to send via `dfx`. To that end, there is an experimental [minting tool](https://github.com/dfinity/experimental-minting-tool) you can use to mint a single-file NFT.

To use this tool, install the minting tool with the command:

`cargo install --git https://github.com/dfinity/experimental-minting-tool --locked`

As an example, such as to mint the default logo, you would run the following command:

```sh
minting-tool local "$(dfx canister id dip721_nft_container)" --owner "$(dfx identity get-principal)" --file ./logo.png --sha2-auto
```

The output of this command should look like this:

```
Successfully minted token 0 to x4d3z-ufpaj-lpxs4-v7gmt-v56ze-aub3k-bvifl-y4lsq-soafd-d3i4k-fqe (transaction id 0)
```

Minting is restricted to anyone authorized with the `custodians` parameter or the `set_custodians` function. Since the contents of `--file` are stored onchain, it's important to prevent arbitrary users from minting tokens, or they will be able to store arbitrarily-sized data in the contract and exhaust the canister's cycles. Be careful not to upload too much data to the canister yourself, or the contract will no longer be able to be upgraded afterwards.
